### 题目链接:
[Largest Rectangle in Histogram][1]


### 整体思想:
![直方图][2]

如上面的直方图，要求出最大的矩形面积。普通的方法是以每个位置作为最低点，然后向两边扩展，
寻找左右边界l, r，比如图中高度为5的位置，左边界l定义为高度1的位置，右边界r定义为右边高度为2
的位置，则矩形的宽度为r -l - 1,然后用宽度乘以高度，求出以当前位置为最低点所能构成最大矩形的
面积，每个位置得出矩形的面积进行比较，就可以得出最大的矩形面积。这样的复杂度是O（n^2)。

用单调栈的思想可以将复杂度降到O（n）。单调栈首先是一个栈，其特点是栈中的元素是单调递增，
栈顶的元素最大，当前元素准备入栈的时候，首先和栈顶比较，如果大于栈顶直接入栈，小于等于的
话则不断弹出栈顶元素，直到栈顶元素小于当前元素。

本题采用单调栈，里面存储的元素并不是具体的高度，而是具体高度在数组里的下标，里面元素对
应的高度是单调递增的。我们称上面提到的一次弹出栈顶元素的操作为一次更新操作，一次更新操
作的效果是：求出了以栈顶元素为最低点，所能构成最大矩形的面积（其实就是求出了左右边界，
然后乘以栈顶元素位置的高度，为什么可以求出来，下面会讲解，很巧妙的方法，单调栈的神奇之
处）。

下面会有三种方法，三种的方法的思想都是一样的，只是在处理边界和收尾工作不一样。下面先贴
代码，然后分别讲解。


### 参考代码1:
该代码是在听完一次视频课以后，自己写的。
```cpp
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        vector<int> h;
        h.push_back(0);
        for(int i = 0; i < heights.size(); i ++)
        {
            h.push_back(heights[i]);
        }
        h.push_back(0);
        stack<int> s;
        s.push(0);
        int ans = 0;
        int n = h.size();
        for(int i = 1; i < n; i++)
        {
            while(h[i] < h[s.top()])
            {
                int a = h[s.top()];//高度
                s.pop();
                int b = i - s.top() - 1;//宽度
                if(ans < a * b)
                    ans = a * b;
            }
            s.push(i);
        }
        return ans;
    }
};

```
以上图为例，高度为2 1 5 6 2 3
将其处理为 h[ ] = { 0, 2, 1, 5, 6, 2, 3, 0}，即在首末位加入0.是为了计算和收尾方便（模拟一遍就会
发现其巧妙之处），下标分别为0, 1, 2, 3, 4, 5, 6, 7。该方法栈中始终不会空，因为一开始有0入栈。
循环遍历每个位置（从1开始）,每次都与栈顶元素对应高度比较，看是否进行更新操作。

这里详细介绍，当循环遍历到下标为5的位置，也就是高度为2时，此时栈里面的元素为0, 2, 3, 4 ,
这都是位置下标，分别对应的高度为0, 1, 5, 6。可以发现高度是递增的。此时在前面已经求出了以
高度为2（最左边）为最低点，所能构成矩形的最大面积，至于为什么能求出以及为什么栈里面的元
素是0,2,3,4，模拟一下就明白了。

当前位置为5，对应高度为2，栈顶元素为4，h[4] = 6, 当前位置对应高度小于栈顶元素对应高度，所
以要进行更新操作。（想想前面最初提出的想法，以每个位置作为最低点，然后向两边扩，能扩充的前
提是两边要比当前位置高度高。）此时已经求出了以栈顶元素为最低点构成矩形的右边界，就是5.因为
它向右边扩不动了，比它要低。下面就是求左边界，先把栈顶元素出栈，此时栈里面的元素为0,2,3.对
应高度为0,1,5。此时左边界也就求出来了，就是新的栈顶元素3，因为栈里面元素对应的高度是递增的,
新的栈顶对应的高度比原来栈顶对应的高度要低，以原来栈顶元素为最低点向左扩，也扩不动了，比它
要低，单调栈的优势充分体现了。这样的话，就可以求出以位置4，高度为6最低点所能构成矩形的面积。
同理，可以接着求出以位置5为最低点所能构成矩形的面积。

当遍历到最后一个位置7时，对应的高度是0，因为要比所有的高度都小，肯定会进行更新操作，所以如
果栈中有元素k的话，1<=k<=6，就可以把这些以k位置为最低点所能构成的最大矩形的面积全部算出来，
即进行了收尾工作。对这个例子来说，模拟到这一步时，可以对单调栈的利用有充分的认识。

下面是另一种方法，它没有在数组首加入0，只在末尾加入了0.参考于网络。
### 参考代码2:
```cpp
class Solution
  {
  public:
      int largestRectangleArea(vector<int> &height)
      {
          int res = 0;
          stack<int> si;
          height.push_back(0);
          for(int i = 0; i < height.size(); ++ i)
         {
             while(!si.empty() && height[si.top()] > height[i])
             {
                 //能进来以后，说明，当前栈顶为最低位置向右延伸不能再延伸了，也就是右边界就是i
                 int h = height[si.top()];
                 si.pop();
                 //si.pop()以后，那么新的栈顶则是以第i个高度为最低的能向左延伸到的左边界
                 int s = h * (si.empty() ? i : (i - si.top() - 1));//高度*宽度就是长方形的面积
                 res = max(res, s);
             }
             si.push(i);
         }
         return res;
     }
 };
```
这种方法可能出现栈为空的情况，所以对si.empty()进行了多次判断，而上一种方法则栈里面不会出现空的
情况，就只有这一点不同，效果都是一样的。

下面是第三种方法，Java写的，要完成的函数参数给的是int[] heights, 因为无法在该数组的基础上后面再加
上一个0，所以与第二种方法相比，收尾工作是单独进行的，不是扫描一遍就可以。
### 参考代码3:
```java
public class Solution {
    public int largestRectangleArea(int[] heights) {
        int ans = 0;
        Stack<Integer> si = new Stack<Integer>();
        int n = heights.length;
        for(int i = 0; i < n; ++i){
        	while(!si.empty() && heights[si.peek()] >= heights[i]){
        		int h = heights[si.peek()];
        		si.pop();
        		int w = si.empty() ? i : (i - si.peek() - 1);
        		ans = Integer.max(ans , h * w);
        	}
        	si.push(i);
        }
        //不为空的时候，单独进行收尾工作
        while(!si.empty()){
        	int h = heights[si.peek()];
        	si.pop();
        	int w = si.empty() ? n : (n - si.peek() - 1); //画画图就知道为什么了
        	ans = Integer.max(ans, h * w);
        }
        return ans;
    }
}
```
如果对以上哪里不懂的话，最好的方法就是拿实例进行模拟，模拟一遍就懂了。仔细体会一下，这种算法
很奇妙。



  [1]:https://leetcode.com/problems/largest-rectangle-in-histogram/
  [2]: http://articles.leetcode.com/wp-content/uploads/2012/04/histogram_area.png
